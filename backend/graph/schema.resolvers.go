package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"context"
	"fmt"
	"golang_saas/graph/model"
	"golang_saas/middleware"
	"golang_saas/models"
	"golang_saas/services"
	"golang_saas/utils"
	"time"

	"github.com/google/uuid"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	authService := services.NewAuthService()

	var tenantID *uuid.UUID
	if input.TenantSlug != nil {
		// Find tenant by slug
		var tenant models.Tenant
		err := r.DB.Where("slug = ?", *input.TenantSlug).First(&tenant).Error
		if err != nil {
			return nil, fmt.Errorf("tenant not found: %w", err)
		}
		tenantID = &tenant.ID
	}

	req := services.RegisterRequest{
		Email:     input.Email,
		Password:  input.Password,
		FirstName: input.FirstName,
		LastName:  input.LastName,
		TenantID:  tenantID,
	}

	authResponse, err := authService.Register(req)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token:        authResponse.Token,
		RefreshToken: authResponse.RefreshToken,
		User:         authResponse.User,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	authService := services.NewAuthService()

	var tenantID *uuid.UUID
	if input.TenantSlug != nil {
		// Find tenant by slug
		var tenant models.Tenant
		err := r.DB.Where("slug = ?", *input.TenantSlug).First(&tenant).Error
		if err != nil {
			return nil, fmt.Errorf("tenant not found: %w", err)
		}
		tenantID = &tenant.ID
	}

	req := services.LoginRequest{
		Email:    input.Email,
		Password: input.Password,
	}

	authResponse, err := authService.Login(req, tenantID)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token:        authResponse.Token,
		RefreshToken: authResponse.RefreshToken,
		User:         authResponse.User,
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, token string) (*model.AuthPayload, error) {
	authService := services.NewAuthService()

	authResponse, err := authService.RefreshToken(token)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token:        authResponse.Token,
		RefreshToken: authResponse.RefreshToken,
		User:         authResponse.User,
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	// For stateless JWT, logout is typically handled client-side
	// You could implement token blacklisting here if needed
	return true, nil
}

// CreateTenant is the resolver for the createTenant field.
func (r *mutationResolver) CreateTenant(ctx context.Context, input model.CreateTenantInput) (*models.Tenant, error) {
	// Require system admin access
	if err := middleware.RequirePermission(ctx, "system:tenant:create"); err != nil {
		return nil, err
	}

	// Check if slug is available
	var existingTenant models.Tenant
	err := r.DB.Where("slug = ?", input.Slug).First(&existingTenant).Error
	if err == nil {
		return nil, fmt.Errorf("tenant slug already exists")
	}

	// Get the plan
	planID, err := uuid.Parse(input.PlanID)
	if err != nil {
		return nil, fmt.Errorf("invalid plan ID: %w", err)
	}

	var plan models.Plan
	err = r.DB.First(&plan, planID).Error
	if err != nil {
		return nil, fmt.Errorf("plan not found: %w", err)
	}

	// Create tenant
	tenant := models.Tenant{
		Name:      input.Name,
		Slug:      input.Slug,
		Domain:    input.Domain,
		Subdomain: input.Subdomain,
		Status:    models.TenantStatusActive,
	}

	err = r.DB.Create(&tenant).Error
	if err != nil {
		return nil, fmt.Errorf("failed to create tenant: %w", err)
	}

	// Create subscription
	subscription := models.Subscription{
		TenantID:           tenant.ID,
		PlanID:             planID,
		Status:             models.SubscriptionStatusActive,
		CurrentPeriodStart: time.Now(),
		CurrentPeriodEnd:   time.Now().AddDate(0, 1, 0), // 1 month from now
	}

	err = r.DB.Create(&subscription).Error
	if err != nil {
		return nil, fmt.Errorf("failed to create subscription: %w", err)
	}

	// Create admin user for tenant
	hashedPassword, err := utils.HashPassword(input.AdminPassword)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	// Get tenant admin role
	var adminRole models.Role
	err = r.DB.Where("name = ?", "tenant_admin").First(&adminRole).Error
	if err != nil {
		return nil, fmt.Errorf("admin role not found: %w", err)
	}

	adminUser := models.User{
		Email:     input.AdminEmail,
		Password:  hashedPassword,
		FirstName: input.AdminFirstName,
		LastName:  input.AdminLastName,
		IsActive:  true,
		TenantID:  &tenant.ID,
		RoleID:    adminRole.ID,
	}

	err = r.DB.Create(&adminUser).Error
	if err != nil {
		return nil, fmt.Errorf("failed to create admin user: %w", err)
	}

	return &tenant, nil
}

// UpdateTenant is the resolver for the updateTenant field.
func (r *mutationResolver) UpdateTenant(ctx context.Context, id string, input model.UpdateTenantInput) (*models.Tenant, error) {
	// Parse tenant ID
	tenantID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid tenant ID: %w", err)
	}

	// Check access
	if err := middleware.RequireTenantAccess(ctx, tenantID); err != nil {
		return nil, err
	}

	// Get tenant
	var tenant models.Tenant
	err = r.DB.First(&tenant, tenantID).Error
	if err != nil {
		return nil, fmt.Errorf("tenant not found: %w", err)
	}

	// Update fields
	if input.Name != nil {
		tenant.Name = *input.Name
	}
	if input.Domain != nil {
		tenant.Domain = input.Domain
	}

	err = r.DB.Save(&tenant).Error
	if err != nil {
		return nil, fmt.Errorf("failed to update tenant: %w", err)
	}

	return &tenant, nil
}

// DeleteTenant is the resolver for the deleteTenant field.
func (r *mutationResolver) DeleteTenant(ctx context.Context, id string) (bool, error) {
	// Require system admin access
	if err := middleware.RequirePermission(ctx, "system:tenant:delete"); err != nil {
		return false, err
	}

	// Parse tenant ID
	tenantID, err := uuid.Parse(id)
	if err != nil {
		return false, fmt.Errorf("invalid tenant ID: %w", err)
	}

	// Soft delete tenant
	err = r.DB.Delete(&models.Tenant{BaseModel: models.BaseModel{ID: tenantID}}).Error
	if err != nil {
		return false, fmt.Errorf("failed to delete tenant: %w", err)
	}

	return true, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*models.User, error) {
	// Require user creation permission
	if err := middleware.RequirePermission(ctx, "user:create"); err != nil {
		return nil, err
	}

	// Get current user context to determine tenant
	currentUser, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	// Parse role ID
	roleID, err := uuid.Parse(input.RoleID)
	if err != nil {
		return nil, fmt.Errorf("invalid role ID: %w", err)
	}

	// Check if role exists and user has access to assign it
	var role models.Role
	query := r.DB.Where("id = ?", roleID)
	if currentUser.TenantID != nil {
		// Tenant users can only assign roles within their tenant
		query = query.Where("tenant_id = ? OR tenant_id IS NULL", currentUser.TenantID)
	}

	err = query.First(&role).Error
	if err != nil {
		return nil, fmt.Errorf("role not found or access denied: %w", err)
	}

	// Hash password
	hashedPassword, err := utils.HashPassword(input.Password)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	// Create user
	user := models.User{
		Email:     input.Email,
		Password:  hashedPassword,
		FirstName: input.FirstName,
		LastName:  input.LastName,
		IsActive:  true,
		TenantID:  currentUser.TenantID,
		RoleID:    roleID,
	}

	err = r.DB.Create(&user).Error
	if err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	// Load relationships
	err = r.DB.Preload("Role").Preload("Tenant").First(&user, user.ID).Error
	if err != nil {
		return nil, fmt.Errorf("failed to load user: %w", err)
	}

	return &user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UpdateUserInput) (*models.User, error) {
	// Parse user ID
	userID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Get user
	var user models.User
	err = r.DB.First(&user, userID).Error
	if err != nil {
		return nil, fmt.Errorf("user not found: %w", err)
	}

	// Check access - users can only update users in their tenant or themselves
	currentUser, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	if currentUser.ID != user.ID {
		if err := middleware.RequirePermission(ctx, "user:update"); err != nil {
			return nil, err
		}

		// Check tenant access
		if currentUser.TenantID == nil && user.TenantID != nil {
			// System users can access any tenant user
		} else if currentUser.TenantID != nil && user.TenantID != nil {
			if *currentUser.TenantID != *user.TenantID {
				return nil, fmt.Errorf("access denied: cannot update user from different tenant")
			}
		}
	}

	// Update fields
	if input.FirstName != nil {
		user.FirstName = *input.FirstName
	}
	if input.LastName != nil {
		user.LastName = *input.LastName
	}
	if input.IsActive != nil {
		user.IsActive = *input.IsActive
	}
	if input.RoleID != nil {
		roleID, err := uuid.Parse(*input.RoleID)
		if err != nil {
			return nil, fmt.Errorf("invalid role ID: %w", err)
		}
		user.RoleID = roleID
	}

	err = r.DB.Save(&user).Error
	if err != nil {
		return nil, fmt.Errorf("failed to update user: %w", err)
	}

	// Load relationships
	err = r.DB.Preload("Role").Preload("Tenant").First(&user, user.ID).Error
	if err != nil {
		return nil, fmt.Errorf("failed to load user: %w", err)
	}

	return &user, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	// Require user deletion permission
	if err := middleware.RequirePermission(ctx, "user:delete"); err != nil {
		return false, err
	}

	// Parse user ID
	userID, err := uuid.Parse(id)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}

	// Soft delete user
	err = r.DB.Delete(&models.User{BaseModel: models.BaseModel{ID: userID}}).Error
	if err != nil {
		return false, fmt.Errorf("failed to delete user: %w", err)
	}

	return true, nil
}

// CreateRole is the resolver for the createRole field.
func (r *mutationResolver) CreateRole(ctx context.Context, input model.CreateRoleInput) (*models.Role, error) {
	// Require role creation permission
	if err := middleware.RequirePermission(ctx, "roles:create"); err != nil {
		return nil, err
	}

	// Get current user context to determine tenant
	currentUser, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	// Create role
	role := models.Role{
		Name:        input.Name,
		Description: input.Description,
		TenantID:    currentUser.TenantID,
	}

	err = r.DB.Create(&role).Error
	if err != nil {
		return nil, fmt.Errorf("failed to create role: %w", err)
	}

	// Assign permissions if provided
	if len(input.PermissionIds) > 0 {
		var permissions []*models.Permission
		for _, permissionIDStr := range input.PermissionIds {
			permissionID, err := uuid.Parse(permissionIDStr)
			if err != nil {
				return nil, fmt.Errorf("invalid permission ID: %w", err)
			}

			var permission models.Permission
			err = r.DB.First(&permission, permissionID).Error
			if err != nil {
				return nil, fmt.Errorf("permission not found: %w", err)
			}
			permissions = append(permissions, &permission)
		}

		err = r.DB.Model(&role).Association("Permissions").Replace(permissions)
		if err != nil {
			return nil, fmt.Errorf("failed to assign permissions: %w", err)
		}
	}

	// Load relationships
	err = r.DB.Preload("Permissions").First(&role, role.ID).Error
	if err != nil {
		return nil, fmt.Errorf("failed to load role: %w", err)
	}

	return &role, nil
}

// UpdateRole is the resolver for the updateRole field.
func (r *mutationResolver) UpdateRole(ctx context.Context, id string, input model.UpdateRoleInput) (*models.Role, error) {
	// Parse role ID
	roleID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid role ID: %w", err)
	}

	// Get role
	var role models.Role
	err = r.DB.First(&role, roleID).Error
	if err != nil {
		return nil, fmt.Errorf("role not found: %w", err)
	}

	// Check access
	currentUser, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	// Require role update permission
	if err := middleware.RequirePermission(ctx, "roles:update"); err != nil {
		return nil, err
	}

	// Check tenant access for non-system roles
	if role.TenantID != nil {
		if currentUser.TenantID == nil {
			// System users can access any tenant role
		} else if *currentUser.TenantID != *role.TenantID {
			return nil, fmt.Errorf("access denied: cannot update role from different tenant")
		}
	}

	// Update fields
	if input.Name != nil {
		role.Name = *input.Name
	}
	if input.Description != nil {
		role.Description = input.Description
	}

	err = r.DB.Save(&role).Error
	if err != nil {
		return nil, fmt.Errorf("failed to update role: %w", err)
	}

	// Update permissions if provided
	if input.PermissionIds != nil {
		var permissions []*models.Permission
		for _, permissionIDStr := range input.PermissionIds {
			permissionID, err := uuid.Parse(permissionIDStr)
			if err != nil {
				return nil, fmt.Errorf("invalid permission ID: %w", err)
			}

			var permission models.Permission
			err = r.DB.First(&permission, permissionID).Error
			if err != nil {
				return nil, fmt.Errorf("permission not found: %w", err)
			}
			permissions = append(permissions, &permission)
		}

		err = r.DB.Model(&role).Association("Permissions").Replace(permissions)
		if err != nil {
			return nil, fmt.Errorf("failed to update permissions: %w", err)
		}
	}

	// Load relationships
	err = r.DB.Preload("Permissions").First(&role, role.ID).Error
	if err != nil {
		return nil, fmt.Errorf("failed to load role: %w", err)
	}

	return &role, nil
}

// DeleteRole is the resolver for the deleteRole field.
func (r *mutationResolver) DeleteRole(ctx context.Context, id string) (bool, error) {
	// Parse role ID
	roleID, err := uuid.Parse(id)
	if err != nil {
		return false, fmt.Errorf("invalid role ID: %w", err)
	}

	// Get role
	var role models.Role
	err = r.DB.First(&role, roleID).Error
	if err != nil {
		return false, fmt.Errorf("role not found: %w", err)
	}

	// Check access
	currentUser, err := middleware.RequireAuth(ctx)
	if err != nil {
		return false, err
	}

	// Require role deletion permission
	if err := middleware.RequirePermission(ctx, "roles:delete"); err != nil {
		return false, err
	}

	// Check tenant access for non-system roles
	if role.TenantID != nil {
		if currentUser.TenantID == nil {
			// System users can access any tenant role
		} else if *currentUser.TenantID != *role.TenantID {
			return false, fmt.Errorf("access denied: cannot delete role from different tenant")
		}
	}

	// Check if role is in use
	var userCount int64
	err = r.DB.Model(&models.User{}).Where("role_id = ?", roleID).Count(&userCount).Error
	if err != nil {
		return false, fmt.Errorf("failed to check role usage: %w", err)
	}

	if userCount > 0 {
		return false, fmt.Errorf("cannot delete role: %d users are assigned to this role", userCount)
	}

	// Delete role
	err = r.DB.Delete(&role).Error
	if err != nil {
		return false, fmt.Errorf("failed to delete role: %w", err)
	}

	return true, nil
}

// ID is the resolver for the id field.
func (r *permissionResolver) ID(ctx context.Context, obj *models.Permission) (string, error) {
	return obj.ID.String(), nil
}

// ID is the resolver for the id field.
func (r *planResolver) ID(ctx context.Context, obj *models.Plan) (string, error) {
	return obj.ID.String(), nil
}

// Features is the resolver for the features field.
func (r *planResolver) Features(ctx context.Context, obj *models.Plan) (map[string]any, error) {
	if obj.Features == nil {
		return map[string]any{}, nil
	}

	var features map[string]any
	if err := obj.Features.Scan(&features); err != nil {
		return nil, fmt.Errorf("failed to parse plan features: %w", err)
	}

	return features, nil
}

// MaxUsers is the resolver for the maxUsers field.
func (r *planResolver) MaxUsers(ctx context.Context, obj *models.Plan) (int32, error) {
	return int32(obj.MaxUsers), nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*models.User, error) {
	user, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	// Load relationships
	err = r.DB.Preload("Role").Preload("Role.Permissions").Preload("Tenant").First(user, user.ID).Error
	if err != nil {
		return nil, fmt.Errorf("failed to load user: %w", err)
	}

	return user, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, filter *model.UserFilter, pagination *model.PaginationInput) (*model.PaginatedUsers, error) {
	// Require user:read permission
	if err := middleware.RequirePermission(ctx, "user:read"); err != nil {
		return nil, err
	}

	// Get current user for tenant filtering
	currentUser, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	// Build query
	query := r.DB.Model(&models.User{})

	// Apply tenant filtering for non-system users
	if currentUser.TenantID != nil {
		query = query.Where("tenant_id = ?", currentUser.TenantID)
	}

	// Apply filters
	if filter != nil {
		if filter.Email != nil {
			query = query.Where("email ILIKE ?", "%"+*filter.Email+"%")
		}
		if filter.IsActive != nil {
			query = query.Where("is_active = ?", *filter.IsActive)
		}
		if filter.RoleID != nil {
			roleID, err := uuid.Parse(*filter.RoleID)
			if err != nil {
				return nil, fmt.Errorf("invalid role ID: %w", err)
			}
			query = query.Where("role_id = ?", roleID)
		}
		if filter.TenantID != nil {
			// Only allow if current user has system access
			if currentUser.TenantID != nil {
				return nil, fmt.Errorf("access denied: cannot filter by tenant")
			}
			tenantID, err := uuid.Parse(*filter.TenantID)
			if err != nil {
				return nil, fmt.Errorf("invalid tenant ID: %w", err)
			}
			query = query.Where("tenant_id = ?", tenantID)
		}
	}

	// Count total
	var total int64
	if err := query.Count(&total).Error; err != nil {
		return nil, fmt.Errorf("failed to count users: %w", err)
	}

	// Apply pagination
	page := int32(1)
	limit := int32(10)
	if pagination != nil {
		if pagination.Page != nil {
			page = *pagination.Page
		}
		if pagination.Limit != nil {
			limit = *pagination.Limit
		}
	}

	offset := (page - 1) * limit
	totalPages := (int32(total) + limit - 1) / limit

	var users []*models.User
	err = query.Preload("Role").Preload("Tenant").Offset(int(offset)).Limit(int(limit)).Find(&users).Error
	if err != nil {
		return nil, fmt.Errorf("failed to fetch users: %w", err)
	}

	return &model.PaginatedUsers{
		Users:      users,
		Total:      int32(total),
		Page:       page,
		Limit:      limit,
		TotalPages: totalPages,
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*models.User, error) {
	// Require user:read permission
	if err := middleware.RequirePermission(ctx, "user:read"); err != nil {
		return nil, err
	}

	// Parse user ID
	userID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Get user
	var user models.User
	err = r.DB.Preload("Role").Preload("Role.Permissions").Preload("Tenant").First(&user, userID).Error
	if err != nil {
		return nil, fmt.Errorf("user not found: %w", err)
	}

	// Check access
	currentUser, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	// Users can only access users in their tenant or themselves
	if currentUser.ID != user.ID {
		if currentUser.TenantID == nil && user.TenantID != nil {
			// System users can access any tenant user
		} else if currentUser.TenantID != nil && user.TenantID != nil {
			if *currentUser.TenantID != *user.TenantID {
				return nil, fmt.Errorf("access denied: cannot access user from different tenant")
			}
		}
	}

	return &user, nil
}

// Tenants is the resolver for the tenants field.
func (r *queryResolver) Tenants(ctx context.Context, filter *model.TenantFilter, pagination *model.PaginationInput) (*model.PaginatedTenants, error) {
	// Require system admin access to list all tenants
	if err := middleware.RequirePermission(ctx, "system:tenant:read"); err != nil {
		return nil, err
	}

	// Build query
	query := r.DB.Model(&models.Tenant{})

	// Apply filters
	if filter != nil {
		if filter.Name != nil {
			query = query.Where("name ILIKE ?", "%"+*filter.Name+"%")
		}
		if filter.Status != nil {
			query = query.Where("status = ?", *filter.Status)
		}
	}

	// Count total
	var total int64
	if err := query.Count(&total).Error; err != nil {
		return nil, fmt.Errorf("failed to count tenants: %w", err)
	}

	// Apply pagination
	page := int32(1)
	limit := int32(10)
	if pagination != nil {
		if pagination.Page != nil {
			page = *pagination.Page
		}
		if pagination.Limit != nil {
			limit = *pagination.Limit
		}
	}

	offset := (page - 1) * limit
	totalPages := (int32(total) + limit - 1) / limit

	var tenants []*models.Tenant
	err := query.Preload("Subscriptions").Preload("Subscriptions.Plan").Offset(int(offset)).Limit(int(limit)).Find(&tenants).Error
	if err != nil {
		return nil, fmt.Errorf("failed to fetch tenants: %w", err)
	}

	return &model.PaginatedTenants{
		Tenants:    tenants,
		Total:      int32(total),
		Page:       page,
		Limit:      limit,
		TotalPages: totalPages,
	}, nil
}

// Tenant is the resolver for the tenant field.
func (r *queryResolver) Tenant(ctx context.Context, id string) (*models.Tenant, error) {
	// Require system admin access or tenant access
	if err := middleware.RequirePermission(ctx, "system:tenant:read"); err != nil {
		// Check if user can access their own tenant
		currentUser, userErr := middleware.RequireAuth(ctx)
		if userErr != nil {
			return nil, err
		}

		tenantID, parseErr := uuid.Parse(id)
		if parseErr != nil {
			return nil, fmt.Errorf("invalid tenant ID: %w", parseErr)
		}

		if currentUser.TenantID == nil || *currentUser.TenantID != tenantID {
			return nil, err
		}
	}

	// Parse tenant ID
	tenantID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid tenant ID: %w", err)
	}

	// Get tenant
	var tenant models.Tenant
	err = r.DB.Preload("Subscriptions").Preload("Subscriptions.Plan").First(&tenant, tenantID).Error
	if err != nil {
		return nil, fmt.Errorf("tenant not found: %w", err)
	}

	return &tenant, nil
}

// TenantBySlug is the resolver for the tenantBySlug field.
func (r *queryResolver) TenantBySlug(ctx context.Context, slug string) (*models.Tenant, error) {
	// This is typically a public endpoint for tenant discovery
	// but we can still require basic authentication

	// Get tenant by slug
	var tenant models.Tenant
	err := r.DB.Where("slug = ?", slug).Preload("Subscriptions").Preload("Subscriptions.Plan").First(&tenant).Error
	if err != nil {
		return nil, fmt.Errorf("tenant not found: %w", err)
	}

	return &tenant, nil
}

// Roles is the resolver for the roles field.
func (r *queryResolver) Roles(ctx context.Context) ([]*models.Role, error) {
	// Require permission to read roles
	if err := middleware.RequirePermission(ctx, "roles:read"); err != nil {
		return nil, err
	}

	// Get current user for tenant filtering
	currentUser, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	// Build query
	query := r.DB.Model(&models.Role{}).Preload("Permissions")

	// Apply tenant filtering for non-system users
	if currentUser.TenantID != nil {
		query = query.Where("tenant_id = ? OR tenant_id IS NULL", currentUser.TenantID)
	}

	var roles []*models.Role
	err = query.Find(&roles).Error
	if err != nil {
		return nil, fmt.Errorf("failed to fetch roles: %w", err)
	}

	return roles, nil
}

// Role is the resolver for the role field.
func (r *queryResolver) Role(ctx context.Context, id string) (*models.Role, error) {
	// Require role read permission
	if err := middleware.RequirePermission(ctx, "roles:read"); err != nil {
		return nil, err
	}

	// Parse role ID
	roleID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid role ID: %w", err)
	}

	// Get current user for tenant filtering
	currentUser, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	// Get role
	var role models.Role
	query := r.DB.Preload("Permissions").Where("id = ?", roleID)

	// Apply tenant filtering for non-system users
	if currentUser.TenantID != nil {
		query = query.Where("tenant_id = ? OR tenant_id IS NULL", currentUser.TenantID)
	}

	err = query.First(&role).Error
	if err != nil {
		return nil, fmt.Errorf("role not found: %w", err)
	}

	return &role, nil
}

// Permissions is the resolver for the permissions field.
func (r *queryResolver) Permissions(ctx context.Context) ([]*models.Permission, error) {
	// Require permission to read permissions
	if err := middleware.RequirePermission(ctx, "roles:read"); err != nil {
		return nil, err
	}

	var permissions []*models.Permission
	err := r.DB.Find(&permissions).Error
	if err != nil {
		return nil, fmt.Errorf("failed to fetch permissions: %w", err)
	}

	return permissions, nil
}

// Plans is the resolver for the plans field.
func (r *queryResolver) Plans(ctx context.Context) ([]*models.Plan, error) {
	var plans []*models.Plan
	err := r.DB.Find(&plans).Error
	if err != nil {
		return nil, fmt.Errorf("failed to fetch plans: %w", err)
	}
	return plans, nil
}

// Plan is the resolver for the plan field.
func (r *queryResolver) Plan(ctx context.Context, id string) (*models.Plan, error) {
	planID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid plan ID: %w", err)
	}

	var plan models.Plan
	err = r.DB.First(&plan, planID).Error
	if err != nil {
		return nil, fmt.Errorf("plan not found: %w", err)
	}

	return &plan, nil
}

// SystemSettings is the resolver for the systemSettings field.
func (r *queryResolver) SystemSettings(ctx context.Context) ([]*models.SystemSettings, error) {
	// Require system admin access
	if err := middleware.RequirePermission(ctx, "system:settings:read"); err != nil {
		return nil, err
	}

	var settings []*models.SystemSettings
	err := r.DB.Find(&settings).Error
	if err != nil {
		return nil, fmt.Errorf("failed to fetch system settings: %w", err)
	}

	return settings, nil
}

// ID is the resolver for the id field.
func (r *roleResolver) ID(ctx context.Context, obj *models.Role) (string, error) {
	return obj.ID.String(), nil
}

// TenantID is the resolver for the tenantId field.
func (r *roleResolver) TenantID(ctx context.Context, obj *models.Role) (*string, error) {
	if obj.TenantID == nil {
		return nil, nil
	}
	tenantIDStr := obj.TenantID.String()
	return &tenantIDStr, nil
}

// ID is the resolver for the id field.
func (r *systemSettingsResolver) ID(ctx context.Context, obj *models.SystemSettings) (string, error) {
	return obj.ID.String(), nil
}

// Value is the resolver for the value field.
func (r *systemSettingsResolver) Value(ctx context.Context, obj *models.SystemSettings) (map[string]any, error) {
	if obj.Value == nil {
		return map[string]any{}, nil
	}

	var value map[string]any
	if err := obj.Value.Scan(&value); err != nil {
		return nil, fmt.Errorf("failed to parse system settings value: %w", err)
	}

	return value, nil
}

// ID is the resolver for the id field.
func (r *tenantResolver) ID(ctx context.Context, obj *models.Tenant) (string, error) {
	return obj.ID.String(), nil
}

// Settings is the resolver for the settings field.
func (r *tenantResolver) Settings(ctx context.Context, obj *models.Tenant) (map[string]any, error) {
	if obj.Settings == nil {
		return map[string]any{}, nil
	}

	var settings map[string]any
	if err := obj.Settings.Scan(&settings); err != nil {
		return nil, fmt.Errorf("failed to parse tenant settings: %w", err)
	}

	return settings, nil
}

// ID is the resolver for the id field.
func (r *tenantSubscriptionResolver) ID(ctx context.Context, obj *models.Subscription) (string, error) {
	return obj.ID.String(), nil
}

// TenantID is the resolver for the tenantId field.
func (r *tenantSubscriptionResolver) TenantID(ctx context.Context, obj *models.Subscription) (string, error) {
	return obj.TenantID.String(), nil
}

// PlanID is the resolver for the planId field.
func (r *tenantSubscriptionResolver) PlanID(ctx context.Context, obj *models.Subscription) (string, error) {
	return obj.PlanID.String(), nil
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *models.User) (string, error) {
	return obj.ID.String(), nil
}

// TenantID is the resolver for the tenantId field.
func (r *userResolver) TenantID(ctx context.Context, obj *models.User) (*string, error) {
	if obj.TenantID == nil {
		return nil, nil
	}
	tenantIDStr := obj.TenantID.String()
	return &tenantIDStr, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Permission returns PermissionResolver implementation.
func (r *Resolver) Permission() PermissionResolver { return &permissionResolver{r} }

// Plan returns PlanResolver implementation.
func (r *Resolver) Plan() PlanResolver { return &planResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Role returns RoleResolver implementation.
func (r *Resolver) Role() RoleResolver { return &roleResolver{r} }

// SystemSettings returns SystemSettingsResolver implementation.
func (r *Resolver) SystemSettings() SystemSettingsResolver { return &systemSettingsResolver{r} }

// Tenant returns TenantResolver implementation.
func (r *Resolver) Tenant() TenantResolver { return &tenantResolver{r} }

// TenantSubscription returns TenantSubscriptionResolver implementation.
func (r *Resolver) TenantSubscription() TenantSubscriptionResolver {
	return &tenantSubscriptionResolver{r}
}

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type permissionResolver struct{ *Resolver }
type planResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type roleResolver struct{ *Resolver }
type systemSettingsResolver struct{ *Resolver }
type tenantResolver struct{ *Resolver }
type tenantSubscriptionResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
